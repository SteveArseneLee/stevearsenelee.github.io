<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>운영체제 on LogLee&#39;s Training Ground</title>
    <link>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/</link>
    <description>Recent content in 운영체제 on LogLee&#39;s Training Ground</description>
    <generator>Hugo</generator>
    <language>ko</language>
    <atom:link href="http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. Process &amp; Thread</title>
      <link>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1-process-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1-process-thread/</guid>
      <description>&lt;h2 id=&#34;1-정의&#34;&gt;&#xA;  1. 정의&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%ec%a0%95%ec%9d%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;프로세스-process&#34;&gt;&#xA;  프로세스 (Process)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-process&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;실행 중인 프로그램의 인스턴스&lt;/li&gt;&#xA;&lt;li&gt;운영체제로부터 독립된 메모리 공간, 자원을 할당받음&lt;/li&gt;&#xA;&lt;li&gt;자체 주소 공간, 코드 영역, 데이터, 힙, 스택을 가짐&lt;/li&gt;&#xA;&lt;li&gt;각 프로세스는 **PCB(Process Control Block)**로 커널이 관리&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;스레드-thread&#34;&gt;&#xA;  스레드 (Thread)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%ec%8a%a4%eb%a0%88%eb%93%9c-thread&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;프로세스 내부에서 실행되는 작업의 흐름 단위&lt;/li&gt;&#xA;&lt;li&gt;코드, 데이터, 힙, 파일 디스크립터 등을 프로세스 내 다른 스레드와 공유&lt;/li&gt;&#xA;&lt;li&gt;스택과 레지스터는 독립적으로 가짐&lt;/li&gt;&#xA;&lt;li&gt;**TCB(Thread Control Block)**로 커널/라이브러리가 관리&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-구조-및-차이점&#34;&gt;&#xA;  2. 구조 및 차이점&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%ea%b5%ac%ec%a1%b0-%eb%b0%8f-%ec%b0%a8%ec%9d%b4%ec%a0%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;항목&lt;/th&gt;&#xA;          &lt;th&gt;프로세스&lt;/th&gt;&#xA;          &lt;th&gt;스레드&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;정의&lt;/td&gt;&#xA;          &lt;td&gt;실행 중인 프로그램의 인스턴스&lt;/td&gt;&#xA;          &lt;td&gt;프로세스 내 작업 흐름 단위&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;메모리 구조&lt;/td&gt;&#xA;          &lt;td&gt;코드, 데이터, 힙, 스택 모두 독립&lt;/td&gt;&#xA;          &lt;td&gt;스택만 독립, 나머지 공유&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;자원 공유&lt;/td&gt;&#xA;          &lt;td&gt;없음 (IPC 필요)&lt;/td&gt;&#xA;          &lt;td&gt;있음 (공유 메모리 기반)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;생성 비용&lt;/td&gt;&#xA;          &lt;td&gt;큼 (fork)&lt;/td&gt;&#xA;          &lt;td&gt;작음 (pthread_create)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;컨텍스트 스위칭&lt;/td&gt;&#xA;          &lt;td&gt;주소 공간 전환 포함 → 비용 큼&lt;/td&gt;&#xA;          &lt;td&gt;주소 공간 공유 → 비용 적음&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;안정성&lt;/td&gt;&#xA;          &lt;td&gt;다른 프로세스에 영향 없음&lt;/td&gt;&#xA;          &lt;td&gt;하나의 오류가 전체에 영향 가능&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;3-context-switching&#34;&gt;&#xA;  3. Context Switching&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-context-switching&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU가 실행 중인 작업을 중단하고 다른 실행 단위로 전환하는 과정&lt;/li&gt;&#xA;&lt;li&gt;필요한 정보: PC, 레지스터, 스택 포인터 등&lt;/li&gt;&#xA;&lt;li&gt;스레드 간 전환은 주소 공간이 같아 빠르지만, 동기화 문제 발생 가능&lt;/li&gt;&#xA;&lt;li&gt;프로세스 간 전환은 보호는 뛰어나지만, 오버헤드 큼&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;4-실무-활용-예시&#34;&gt;&#xA;  4. 실무 활용 예시&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%ec%8b%a4%eb%ac%b4-%ed%99%9c%ec%9a%a9-%ec%98%88%ec%8b%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;분야&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;웹 서버&lt;/td&gt;&#xA;          &lt;td&gt;Nginx, Tomcat 등은 클라이언트 요청을 스레드 단위로 분리 처리 (스레드 풀 기반)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;브라우저&lt;/td&gt;&#xA;          &lt;td&gt;Chrome: 탭은 프로세스, 탭 내 동작은 스레드로 분리 (안정성과 병렬성 모두 확보)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;멀티코어 CPU 활용&lt;/td&gt;&#xA;          &lt;td&gt;Python은 GIL로 멀티 스레딩 성능 한계 → 멀티프로세싱 사용 (예: multiprocessing 모듈)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;게임 엔진&lt;/td&gt;&#xA;          &lt;td&gt;렌더링/네트워크/물리 계산을 개별 스레드로 병렬 처리&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;5-관련-명령어-및-실습&#34;&gt;&#xA;  5. 관련 명령어 및 실습&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5-%ea%b4%80%eb%a0%a8-%eb%aa%85%eb%a0%b9%ec%96%b4-%eb%b0%8f-%ec%8b%a4%ec%8a%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ps -ef, top&lt;/td&gt;&#xA;          &lt;td&gt;현재 실행 중인 프로세스 확인&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;htop&lt;/td&gt;&#xA;          &lt;td&gt;F2 → Threads 표시 옵션으로 스레드 확인&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;strace -p &lt;PID&gt;&lt;/td&gt;&#xA;          &lt;td&gt;해당 프로세스의 시스템 콜 흐름 추적&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;pthread_create()&lt;/td&gt;&#xA;          &lt;td&gt;POSIX 스레드 생성 (C/C++)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;java.lang.Thread, Runnable&lt;/td&gt;&#xA;          &lt;td&gt;Java에서의 스레드 작성 방식&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;6-자주-묻는-면접-질문&#34;&gt;&#xA;  6. 자주 묻는 면접 질문&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#6-%ec%9e%90%ec%a3%bc-%eb%ac%bb%eb%8a%94-%eb%a9%b4%ec%a0%91-%ec%a7%88%eb%ac%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q1. 프로세스와 스레드의 차이를 설명해주세요.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2. CPU Scheduling</title>
      <link>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2-cpu-scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2-cpu-scheduling/</guid>
      <description>&lt;h2 id=&#34;1-정의&#34;&gt;&#xA;  1. 정의&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%ec%a0%95%ec%9d%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU 스케줄링은 Ready Queue에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 정책.&lt;/li&gt;&#xA;&lt;li&gt;멀티태스킹 OS에서 프로세스 간 CPU를 공유하기 위한 핵심 메커니즘.&lt;/li&gt;&#xA;&lt;li&gt;OS의 핵심 기능 중 하나로, 스케줄러는 다양한 정책에 따라 프로세스를 선택함.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;주요-목적&#34;&gt;&#xA;  주요 목적&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%ec%a3%bc%ec%9a%94-%eb%aa%a9%ec%a0%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;시스템 자원의 공정한 분배&lt;/li&gt;&#xA;&lt;li&gt;CPU 사용률(Throughput) 극대화&lt;/li&gt;&#xA;&lt;li&gt;대기 시간, 응답 시간 최소화&lt;/li&gt;&#xA;&lt;li&gt;전반적인 시스템 반응성 향상&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-스케쥴링이-필요한-시점&#34;&gt;&#xA;  2. 스케쥴링이 필요한 시점&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81%ec%9d%b4-%ed%95%84%ec%9a%94%ed%95%9c-%ec%8b%9c%ec%a0%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;프로세스가 CPU burst를 마치고 I/O 요청 → CPU 반환&lt;/li&gt;&#xA;&lt;li&gt;프로세스가 종료됨&lt;/li&gt;&#xA;&lt;li&gt;선점형 스케줄러의 경우, 더 높은 우선순위의 프로세스가 도착&lt;/li&gt;&#xA;&lt;li&gt;sleep(), wait() 호출 후 wake up될 때&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;3-주요-스케쥴링-기준&#34;&gt;&#xA;  3. 주요 스케쥴링 기준&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%ec%a3%bc%ec%9a%94-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81-%ea%b8%b0%ec%a4%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;기준&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CPU burst time&lt;/td&gt;&#xA;          &lt;td&gt;얼마나 짧게 CPU를 점유할지&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;우선순위 (Priority)&lt;/td&gt;&#xA;          &lt;td&gt;사용자/시스템 지정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;도착 시간 (Arrival Time)&lt;/td&gt;&#xA;          &lt;td&gt;먼저 온 순서&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;대기 시간 / 응답 시간&lt;/td&gt;&#xA;          &lt;td&gt;유저가 체감하는 반응 속도&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Aging&lt;/td&gt;&#xA;          &lt;td&gt;기아(Starvation) 방지 목적&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;4-스케쥴링-알고리즘&#34;&gt;&#xA;  4. 스케쥴링 알고리즘&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;FCFS (First-Come, First-Served)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;먼저 온 순서대로 처리 (Queue 기반)&lt;/li&gt;&#xA;&lt;li&gt;단순하지만 Convoy 현상 발생 가능 (긴 작업이 짧은 작업을 막음)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;SJF (Shortest Job First)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU burst가 가장 짧은 작업 우선&lt;/li&gt;&#xA;&lt;li&gt;이론상 가장 효율적 (대기시간 최소), 하지만 예측이 어렵다&lt;/li&gt;&#xA;&lt;li&gt;비선점형(기본) 또는 **선점형(SRTF)**으로 구현 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;Round Robin (RR)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;각 프로세스에 Time Quantum 부여&lt;/li&gt;&#xA;&lt;li&gt;시간 할당이 끝나면 선점 발생 → 공정성 ↑&lt;/li&gt;&#xA;&lt;li&gt;응답성이 중요할 때 유용 (인터랙티브 시스템)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;Priority Scheduling&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;우선순위 높은 작업부터 실행&lt;/li&gt;&#xA;&lt;li&gt;Starvation 발생 가능 → Aging 기법으로 완화&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;Multi-Level Queue (MLQ)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;프로세스를 성격에 따라 여러 큐로 분류 (ex. interactive, batch)&lt;/li&gt;&#xA;&lt;li&gt;큐마다 별도 알고리즘 사용&lt;/li&gt;&#xA;&lt;li&gt;큐 간 우선순위 존재 (low queue는 starvation 가능)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;Multi-Level Feedback Queue (MLFQ)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MLQ 확장형, 프로세스가 다른 큐로 이동 가능&lt;/li&gt;&#xA;&lt;li&gt;초기엔 높은 우선순위에서 시작, CPU 오래 쓰면 점점 낮은 우선순위로 이동&lt;/li&gt;&#xA;&lt;li&gt;현대 OS가 채택하는 현실적인 정책&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;5-선점형-vs-비선점형&#34;&gt;&#xA;  5. 선점형 vs 비선점형&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5-%ec%84%a0%ec%a0%90%ed%98%95-vs-%eb%b9%84%ec%84%a0%ec%a0%90%ed%98%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;구분&lt;/th&gt;&#xA;          &lt;th&gt;비선점형&lt;/th&gt;&#xA;          &lt;th&gt;선점형&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;설명&lt;/td&gt;&#xA;          &lt;td&gt;CPU를 할당받으면 자발적으로 반환할 때까지 유지&lt;/td&gt;&#xA;          &lt;td&gt;우선순위 등 조건에 따라 중간에 선점 가능&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;예시 알고리즘&lt;/td&gt;&#xA;          &lt;td&gt;FCFS, SJF&lt;/td&gt;&#xA;          &lt;td&gt;RR, Priority(선점형), SRTF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;특징&lt;/td&gt;&#xA;          &lt;td&gt;단순, context switch 적음&lt;/td&gt;&#xA;          &lt;td&gt;응답성 우수, 복잡도 ↑&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;6-성능-지표&#34;&gt;&#xA;  6. 성능 지표&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#6-%ec%84%b1%eb%8a%a5-%ec%a7%80%ed%91%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;지표&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CPU 사용률&lt;/td&gt;&#xA;          &lt;td&gt;CPU가 놀지 않고 일하는 비율&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Throughput&lt;/td&gt;&#xA;          &lt;td&gt;단위 시간당 완료된 프로세스 수&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Turnaround Time&lt;/td&gt;&#xA;          &lt;td&gt;프로세스 시작 ~ 종료까지 걸린 시간&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Waiting Time&lt;/td&gt;&#xA;          &lt;td&gt;Ready Queue에서 기다린 시간&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Response Time&lt;/td&gt;&#xA;          &lt;td&gt;요청 후 첫 반응까지 걸린 시간&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;7-실무-예시&#34;&gt;&#xA;  7. 실무 예시&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#7-%ec%8b%a4%eb%ac%b4-%ec%98%88%ec%8b%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;OS&lt;/th&gt;&#xA;          &lt;th&gt;스케줄러&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Linux (CFS)&lt;/td&gt;&#xA;          &lt;td&gt;Completely Fair Scheduler – 시간 단위를 Weight로 변환해 공정하게 분배&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Windows&lt;/td&gt;&#xA;          &lt;td&gt;Multilevel Feedback Queue 기반 선점형&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RTOS&lt;/td&gt;&#xA;          &lt;td&gt;Priority-based preemptive scheduling (실시간성 강조)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;=&amp;gt; 📌 Linux CFS는 가상 런타임(VRuntime) 기반으로, 각 태스크의 실행 시간을 추적하며 가장 “덜 사용한” 프로세스에게 CPU를 할당.&lt;/p&gt;</description>
    </item>
    <item>
      <title>3. 프로세스 동기화(Process Synchronization)</title>
      <link>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/3-process-synchronization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/3-process-synchronization/</guid>
      <description>&lt;h2 id=&#34;1-정의&#34;&gt;&#xA;  1. 정의&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%ec%a0%95%ec%9d%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;프로세스 동기화란 둘 이상의 프로세스(또는 스레드)가 공유 자원에 접근할 때 충돌 없이 안전하게 작업할 수 있도록 보장하는 방법.&lt;/li&gt;&#xA;&lt;li&gt;주로 임계 구역(Critical Section) 문제를 해결하기 위한 동기화 메커니즘을 의미.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;-임계-구역-critical-section&#34;&gt;&#xA;  🔹 임계 구역 (Critical Section)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%ec%9e%84%ea%b3%84-%ea%b5%ac%ec%97%ad-critical-section&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;동시에 하나의 프로세스만 접근해야 하는 공유 자원 처리 구간.&lt;/li&gt;&#xA;&lt;li&gt;예: 전역 변수, 공유된 파일, 네트워크 소켓 등&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;-동기화의-목적&#34;&gt;&#xA;  🔹 동기화의 목적&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%eb%8f%99%ea%b8%b0%ed%99%94%ec%9d%98-%eb%aa%a9%ec%a0%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Race Condition 방지: 둘 이상의 프로세스가 데이터를 동시에 읽고 쓰면 비정상적인 결과 발생&lt;/li&gt;&#xA;&lt;li&gt;일관성 유지: 데이터 무결성 보장&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-동기화의-3가지-요구-조건임계-구역-문제-해결-조건&#34;&gt;&#xA;  2. 동기화의 3가지 요구 조건(임계 구역 문제 해결 조건)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%eb%8f%99%ea%b8%b0%ed%99%94%ec%9d%98-3%ea%b0%80%ec%a7%80-%ec%9a%94%ea%b5%ac-%ec%a1%b0%ea%b1%b4%ec%9e%84%ea%b3%84-%ea%b5%ac%ec%97%ad-%eb%ac%b8%ec%a0%9c-%ed%95%b4%ea%b2%b0-%ec%a1%b0%ea%b1%b4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;상호 배제 (Mutual Exclusion): 하나의 프로세스만 임계 구역 실행 가능&lt;/li&gt;&#xA;&lt;li&gt;진행 (Progress): 임계 구역에 진입하지 않은 프로세스는 진입 여부 결정에 관여 X&lt;/li&gt;&#xA;&lt;li&gt;한정 대기 (Bounded Waiting): 무한정 대기 없이 순차적으로 기회 부여&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;3-동기화-주요-기법&#34;&gt;&#xA;  3. 동기화 주요 기법&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%eb%8f%99%ea%b8%b0%ed%99%94-%ec%a3%bc%ec%9a%94-%ea%b8%b0%eb%b2%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;뮤텍스(Mutex, Mutual Exclusion Lock)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;한 번에 하나의 스레드만 락을 획득 가능&lt;/li&gt;&#xA;&lt;li&gt;획득한 스레드만 임계 구역 진입 → 완료 후 unlock&lt;/li&gt;&#xA;&lt;li&gt;소유 개념 있음: 락을 걸고 해제할 수 있는 주체는 동일해야 함&lt;/li&gt;&#xA;&lt;li&gt;사용 예시: pthread_mutex, Java synchronized, C++ std::mutex&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pthread_mutex_t&lt;/span&gt; lock;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pthread_mutex_lock&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lock);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 임계 구역&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pthread_mutex_unlock&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lock);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;세마포어(Semaphore)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;카운팅 가능한 동기화 도구&lt;/li&gt;&#xA;&lt;li&gt;두 가지 연산:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;P() 또는 wait() → 자원 요청 (count–)&lt;/li&gt;&#xA;&lt;li&gt;V() 또는 signal() → 자원 반납 (count++)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;음수가 되면 대기 큐에 블록됨&lt;/li&gt;&#xA;&lt;li&gt;소유 개념 없음 → 다른 스레드가 해제 가능&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;종류&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Binary Semaphore&lt;/td&gt;&#xA;          &lt;td&gt;0 or 1 (뮤텍스와 유사)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Counting Semaphore&lt;/td&gt;&#xA;          &lt;td&gt;특정 수 이상의 동시 접근 허용 가능&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;스핀락(Spinlock)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;락을 획득할 때까지 CPU를 점유한 채 무한 루프(바쁜 대기).&lt;/li&gt;&#xA;&lt;li&gt;컨텍스트 스위치가 비싼 커널 공간이나 짧은 락 소유 시 유리&lt;/li&gt;&#xA;&lt;li&gt;주의: 멀티코어 환경에서만 유효하며, 싱글코어에서 사용하면 CPU 낭비&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;모니터(Monitor)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;언어 수준의 동기화 추상화&lt;/li&gt;&#xA;&lt;li&gt;내부에 Lock + Condition Variable 포함&lt;/li&gt;&#xA;&lt;li&gt;Java, C#, Go 등에서 사용 (synchronized, wait/notify, etc.)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;조건 변수 (Condition Variable)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;어떤 조건이 만족될 때까지 기다리는 데 사용&lt;/li&gt;&#xA;&lt;li&gt;주로 뮤텍스와 함께 사용&lt;/li&gt;&#xA;&lt;li&gt;예시:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pthread_cond_wait()&lt;/li&gt;&#xA;&lt;li&gt;Java Object.wait() / Object.notify()&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;4-race-condition-예제와-해결-방법&#34;&gt;&#xA;  4. Race COndition 예제와 해결 방법&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-race-condition-%ec%98%88%ec%a0%9c%ec%99%80-%ed%95%b4%ea%b2%b0-%eb%b0%a9%eb%b2%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; arg) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000000&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        counter&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;위 코드에서 두 개의 스레드가 동시에 counter++를 수행하면 Race Condition 발생&lt;/li&gt;&#xA;&lt;li&gt;해결책: mutex 사용&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;5-실무-예시&#34;&gt;&#xA;  5. 실무 예시&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5-%ec%8b%a4%eb%ac%b4-%ec%98%88%ec%8b%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;분야&lt;/th&gt;&#xA;          &lt;th&gt;동기화 방식&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;다중 요청 처리 서버 (ex. Tomcat)&lt;/td&gt;&#xA;          &lt;td&gt;Thread Pool + 뮤텍스 / 세마포어&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;생산자-소비자 패턴&lt;/td&gt;&#xA;          &lt;td&gt;Circular Buffer + 조건 변수&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DB connection pool&lt;/td&gt;&#xA;          &lt;td&gt;Counting Semaphore&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;커널 영역 (락 없는 프로그래밍 포함)&lt;/td&gt;&#xA;          &lt;td&gt;Spinlock, 원자 연산, CAS(Compare-And-Swap)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;6-자주-묻는-면접-질문&#34;&gt;&#xA;  6. 자주 묻는 면접 질문&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#6-%ec%9e%90%ec%a3%bc-%eb%ac%bb%eb%8a%94-%eb%a9%b4%ec%a0%91-%ec%a7%88%eb%ac%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q1. 세마포어와 뮤텍스의 차이는?&#xA;A.&lt;/p&gt;</description>
    </item>
    <item>
      <title>4. Deadlock</title>
      <link>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/4-deadlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/4-deadlock/</guid>
      <description>&lt;h2 id=&#34;1-정의&#34;&gt;&#xA;  1. 정의&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%ec%a0%95%ec%9d%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;데드락(교착 상태, Deadlock) 이란 여러 프로세스(또는 스레드)가 서로 자원이 풀리기를 기다리며 무한히 블로킹되어, 더 이상 진행되지 못하는 상태를 의미한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>5. 메모리 관리</title>
      <link>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/5-memory-manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/5-memory-manage/</guid>
      <description>&lt;h2 id=&#34;1-메모리의-계층-구조-및-주소-체계&#34;&gt;&#xA;  1. 메모리의 계층 구조 및 주소 체계&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%eb%a9%94%eb%aa%a8%eb%a6%ac%ec%9d%98-%ea%b3%84%ec%b8%b5-%ea%b5%ac%ec%a1%b0-%eb%b0%8f-%ec%a3%bc%ec%86%8c-%ec%b2%b4%ea%b3%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;메모리-계층-구조&#34;&gt;&#xA;  메모리 계층 구조&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b3%84%ec%b8%b5-%ea%b5%ac%ec%a1%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU -&amp;gt; register -&amp;gt; cache -&amp;gt; main memory(RAM) -&amp;gt; SSD/HDD&lt;/li&gt;&#xA;&lt;li&gt;OS 입장에서는 **main memory(RAM)**을 관리하는 게 핵심&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;주소-체계&#34;&gt;&#xA;  주소 체계&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%ec%a3%bc%ec%86%8c-%ec%b2%b4%ea%b3%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;구분&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;논리 주소(Logical Address)&lt;/td&gt;&#xA;          &lt;td&gt;CPU가 생성한 주소 (프로세스 입장에서의 주소)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;물리 주소(Physical Address)&lt;/td&gt;&#xA;          &lt;td&gt;실제 메모리 하드웨어 상의 주소&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;가상 주소(Virtual Address)&lt;/td&gt;&#xA;          &lt;td&gt;논리 주소와 같으며, MMU가 물리 주소로 변환&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;=&amp;gt; MMU (Memory Management Unit): 논리 주소를 물리 주소로 변환하는 하드웨어. 페이징 기반 시스템에서 핵심 역할.&lt;/p&gt;</description>
    </item>
    <item>
      <title>6. 가상 메모리</title>
      <link>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6-virtual-memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6-virtual-memory/</guid>
      <description>&lt;h2 id=&#34;1-정의&#34;&gt;&#xA;  1. 정의&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%ec%a0%95%ec%9d%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;가상 메모리(Virtual Memory)&lt;/strong&gt; 는 프로세스가 실제 물리 메모리보다 더 큰 주소 공간을 사용할 수 있도록 지원하는 메커니즘&lt;/p&gt;</description>
    </item>
    <item>
      <title>7. File System</title>
      <link>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/7-file-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/7-file-system/</guid>
      <description>&lt;h2 id=&#34;1-파일-시스템의-역할&#34;&gt;&#xA;  1. 파일 시스템의 역할&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%ed%8c%8c%ec%9d%bc-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98-%ec%97%ad%ed%95%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;데이터를 저장하고, 탐색하고, 보호하는 계층&lt;/li&gt;&#xA;&lt;li&gt;저장 장치(HDD, SSD 등)의 추상화 계층을 제공&lt;/li&gt;&#xA;&lt;li&gt;운영체제는 파일 시스템을 통해 파일/디렉토리를 관리함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-inode와-디렉터리-구조&#34;&gt;&#xA;  2. inode와 디렉터리 구조&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-inode%ec%99%80-%eb%94%94%eb%a0%89%ed%84%b0%eb%a6%ac-%ea%b5%ac%ec%a1%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;inode-index-node&#34;&gt;&#xA;  inode (Index Node)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#inode-index-node&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;파일의 metadata를 저장하는 구조체&lt;/li&gt;&#xA;&lt;li&gt;각 파일은 고유한 inode 번호를 가짐 (inode table에 저장)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;포함 정보&lt;/th&gt;&#xA;          &lt;th&gt;예시&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;파일 크기&lt;/td&gt;&#xA;          &lt;td&gt;512KB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;생성/수정/접근 시간&lt;/td&gt;&#xA;          &lt;td&gt;stat 명령으로 확인&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;접근 권한&lt;/td&gt;&#xA;          &lt;td&gt;rwxr-xr–&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;링크 수&lt;/td&gt;&#xA;          &lt;td&gt;hard link 개수&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;디스크 블록 위치 정보&lt;/td&gt;&#xA;          &lt;td&gt;직접/간접 블록 주소 포함&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;=&amp;gt; inode는 filename은 저장하지 않음 -&amp;gt; directory entry가 filename과 inode 번호를 매핑&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
