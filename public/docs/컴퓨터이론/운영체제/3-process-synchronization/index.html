<!doctype html><html lang=ko dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  1. 정의
  #


프로세스 동기화란 둘 이상의 프로세스(또는 스레드)가 공유 자원에 접근할 때 충돌 없이 안전하게 작업할 수 있도록 보장하는 방법.
주로 임계 구역(Critical Section) 문제를 해결하기 위한 동기화 메커니즘을 의미.


  🔹 임계 구역 (Critical Section)
  #


동시에 하나의 프로세스만 접근해야 하는 공유 자원 처리 구간.
예: 전역 변수, 공유된 파일, 네트워크 소켓 등


  🔹 동기화의 목적
  #


Race Condition 방지: 둘 이상의 프로세스가 데이터를 동시에 읽고 쓰면 비정상적인 결과 발생
일관성 유지: 데이터 무결성 보장


  2. 동기화의 3가지 요구 조건(임계 구역 문제 해결 조건)
  #


상호 배제 (Mutual Exclusion): 하나의 프로세스만 임계 구역 실행 가능
진행 (Progress): 임계 구역에 진입하지 않은 프로세스는 진입 여부 결정에 관여 X
한정 대기 (Bounded Waiting): 무한정 대기 없이 순차적으로 기회 부여


  3. 동기화 주요 기법
  #


뮤텍스(Mutex, Mutual Exclusion Lock)


한 번에 하나의 스레드만 락을 획득 가능
획득한 스레드만 임계 구역 진입 → 완료 후 unlock
소유 개념 있음: 락을 걸고 해제할 수 있는 주체는 동일해야 함
사용 예시: pthread_mutex, Java synchronized, C++ std::mutex

pthread_mutex_t lock;

pthread_mutex_lock(&amp;lock);
// 임계 구역
pthread_mutex_unlock(&amp;lock);

세마포어(Semaphore)


카운팅 가능한 동기화 도구
두 가지 연산:

P() 또는 wait() → 자원 요청 (count–)
V() 또는 signal() → 자원 반납 (count++)


음수가 되면 대기 큐에 블록됨
소유 개념 없음 → 다른 스레드가 해제 가능

  
      
          종류
          설명
      
  
  
      
          Binary Semaphore
          0 or 1 (뮤텍스와 유사)
      
      
          Counting Semaphore
          특정 수 이상의 동시 접근 허용 가능
      
  




스핀락(Spinlock)


락을 획득할 때까지 CPU를 점유한 채 무한 루프(바쁜 대기).
컨텍스트 스위치가 비싼 커널 공간이나 짧은 락 소유 시 유리
주의: 멀티코어 환경에서만 유효하며, 싱글코어에서 사용하면 CPU 낭비


모니터(Monitor)


언어 수준의 동기화 추상화
내부에 Lock + Condition Variable 포함
Java, C#, Go 등에서 사용 (synchronized, wait/notify, etc.)


조건 변수 (Condition Variable)


어떤 조건이 만족될 때까지 기다리는 데 사용
주로 뮤텍스와 함께 사용
예시:

pthread_cond_wait()
Java Object.wait() / Object.notify()




  4. Race COndition 예제와 해결 방법
  #

int counter = 0;

void* increment(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        counter++;
    }
}

위 코드에서 두 개의 스레드가 동시에 counter++를 수행하면 Race Condition 발생
해결책: mutex 사용


  5. 실무 예시
  #


  
      
          분야
          동기화 방식
      
  
  
      
          다중 요청 처리 서버 (ex. Tomcat)
          Thread Pool + 뮤텍스 / 세마포어
      
      
          생산자-소비자 패턴
          Circular Buffer + 조건 변수
      
      
          DB connection pool
          Counting Semaphore
      
      
          커널 영역 (락 없는 프로그래밍 포함)
          Spinlock, 원자 연산, CAS(Compare-And-Swap)
      
  


  6. 자주 묻는 면접 질문
  #


Q1. 세마포어와 뮤텍스의 차이는?
A."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://stevearsenelee.iptime.org/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/3-process-synchronization/"><meta property="og:site_name" content="LogLee's Training Ground"><meta property="og:title" content="3. 프로세스 동기화(Process Synchronization)"><meta property="og:description" content="1. 정의 # 프로세스 동기화란 둘 이상의 프로세스(또는 스레드)가 공유 자원에 접근할 때 충돌 없이 안전하게 작업할 수 있도록 보장하는 방법. 주로 임계 구역(Critical Section) 문제를 해결하기 위한 동기화 메커니즘을 의미. 🔹 임계 구역 (Critical Section) # 동시에 하나의 프로세스만 접근해야 하는 공유 자원 처리 구간. 예: 전역 변수, 공유된 파일, 네트워크 소켓 등 🔹 동기화의 목적 # Race Condition 방지: 둘 이상의 프로세스가 데이터를 동시에 읽고 쓰면 비정상적인 결과 발생 일관성 유지: 데이터 무결성 보장 2. 동기화의 3가지 요구 조건(임계 구역 문제 해결 조건) # 상호 배제 (Mutual Exclusion): 하나의 프로세스만 임계 구역 실행 가능 진행 (Progress): 임계 구역에 진입하지 않은 프로세스는 진입 여부 결정에 관여 X 한정 대기 (Bounded Waiting): 무한정 대기 없이 순차적으로 기회 부여 3. 동기화 주요 기법 # 뮤텍스(Mutex, Mutual Exclusion Lock) 한 번에 하나의 스레드만 락을 획득 가능 획득한 스레드만 임계 구역 진입 → 완료 후 unlock 소유 개념 있음: 락을 걸고 해제할 수 있는 주체는 동일해야 함 사용 예시: pthread_mutex, Java synchronized, C++ std::mutex pthread_mutex_t lock; pthread_mutex_lock(&amp;lock); // 임계 구역 pthread_mutex_unlock(&amp;lock); 세마포어(Semaphore) 카운팅 가능한 동기화 도구 두 가지 연산: P() 또는 wait() → 자원 요청 (count–) V() 또는 signal() → 자원 반납 (count++) 음수가 되면 대기 큐에 블록됨 소유 개념 없음 → 다른 스레드가 해제 가능 종류 설명 Binary Semaphore 0 or 1 (뮤텍스와 유사) Counting Semaphore 특정 수 이상의 동시 접근 허용 가능 스핀락(Spinlock) 락을 획득할 때까지 CPU를 점유한 채 무한 루프(바쁜 대기). 컨텍스트 스위치가 비싼 커널 공간이나 짧은 락 소유 시 유리 주의: 멀티코어 환경에서만 유효하며, 싱글코어에서 사용하면 CPU 낭비 모니터(Monitor) 언어 수준의 동기화 추상화 내부에 Lock + Condition Variable 포함 Java, C#, Go 등에서 사용 (synchronized, wait/notify, etc.) 조건 변수 (Condition Variable) 어떤 조건이 만족될 때까지 기다리는 데 사용 주로 뮤텍스와 함께 사용 예시: pthread_cond_wait() Java Object.wait() / Object.notify() 4. Race COndition 예제와 해결 방법 # int counter = 0; void* increment(void* arg) { for (int i = 0; i < 1000000; i++) { counter++; } } 위 코드에서 두 개의 스레드가 동시에 counter++를 수행하면 Race Condition 발생 해결책: mutex 사용 5. 실무 예시 # 분야 동기화 방식 다중 요청 처리 서버 (ex. Tomcat) Thread Pool + 뮤텍스 / 세마포어 생산자-소비자 패턴 Circular Buffer + 조건 변수 DB connection pool Counting Semaphore 커널 영역 (락 없는 프로그래밍 포함) Spinlock, 원자 연산, CAS(Compare-And-Swap) 6. 자주 묻는 면접 질문 # Q1. 세마포어와 뮤텍스의 차이는? A."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>3. 프로세스 동기화(Process Synchronization) | LogLee's Training Ground</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://stevearsenelee.iptime.org/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/3-process-synchronization/><link rel=stylesheet href=/book.min.e9f68c3fff3d8236a489d16a9caf6de5e4d1a29c20eb4b5524e42cd30be4d319.css integrity="sha256-6faMP/89gjakidFqnK9t5eTRopwg60tVJOQs0wvk0xk=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/kr.search.min.7519638bba906ebd7144ec6f10865974a0bf0a20eaf199bab28b9c08e4017da1.js integrity="sha256-dRlji7qQbr1xROxvEIZZdKC/CiDq8Zm6soucCOQBfaE=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>LogLee's Training Ground</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder aria-label maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-ca170abdbca9581a14670b9cae3bc610 class=toggle>
<label for=section-ca170abdbca9581a14670b9cae3bc610 class="flex justify-between"><a href=/docs/infra/>Infra</a></label><ul><li><input type=checkbox id=section-13e9d5199e5227e2fc9d2761cefce5e3 class=toggle>
<label for=section-13e9d5199e5227e2fc9d2761cefce5e3 class="flex justify-between"><a href=/docs/infra/kvm/>KVM</a></label><ul></ul></li><li><input type=checkbox id=section-f81e017d773579a54933834beb44e810 class=toggle>
<label for=section-f81e017d773579a54933834beb44e810 class="flex justify-between"><a href=/docs/infra/kubernetes/>Kubernetes</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-0a6b727fd0c16fe1cd97268a7c41867f class=toggle>
<label for=section-0a6b727fd0c16fe1cd97268a7c41867f class="flex justify-between"><a href=/docs/data-engineering/>Data Engineering</a></label><ul><li><input type=checkbox id=section-62b47f208465b78efb2357a9cd3b2079 class=toggle>
<label for=section-62b47f208465b78efb2357a9cd3b2079 class="flex justify-between"><a href=/docs/data-engineering/hadoop/>Hadoop</a></label><ul></ul></li><li><input type=checkbox id=section-78a946129d8f80712a11a39c8d6ebd9d class=toggle>
<label for=section-78a946129d8f80712a11a39c8d6ebd9d class="flex justify-between"><a href=/docs/data-engineering/modeling/>Modeling</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-f63bbdf8b75866dade3fafe4e1a0afff class=toggle>
<label for=section-f63bbdf8b75866dade3fafe4e1a0afff class="flex justify-between"><a href=/docs/data-integration/>Data Integration</a></label><ul><li><input type=checkbox id=section-79a0757d1ed364d3305442eeb8973397 class=toggle>
<label for=section-79a0757d1ed364d3305442eeb8973397 class="flex justify-between"><a href=/docs/data-integration/kafka/>Kafka</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-6112d994a830508704e67b42557ab468 class=toggle>
<label for=section-6112d994a830508704e67b42557ab468 class="flex justify-between"><a href=/docs/data-lake-platform/>Data Lake Platform</a></label><ul><li><input type=checkbox id=section-da639d08c72951def4c9aaca8e9ac1d2 class=toggle>
<label for=section-da639d08c72951def4c9aaca8e9ac1d2 class="flex justify-between"><a href=/docs/data-lake-platform/ceph/>Ceph</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-7943913a8058166e2057e211419337f8 class=toggle>
<label for=section-7943913a8058166e2057e211419337f8 class="flex justify-between"><a href=/docs/data-processing/>Data Processing</a></label><ul><li><input type=checkbox id=section-b4d28add6c8591349850bd55ed89041a class=toggle>
<label for=section-b4d28add6c8591349850bd55ed89041a class="flex justify-between"><a href=/docs/data-processing/flink/>Flink</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-780e6985e21edbc7ed69c6dc3b8333e0 class=toggle>
<label for=section-780e6985e21edbc7ed69c6dc3b8333e0 class="flex justify-between"><a href=/docs/language/>Language</a></label><ul></ul></li><li><input type=checkbox id=section-fff819996f2500b94ce5cef541863bca class=toggle>
<label for=section-fff819996f2500b94ce5cef541863bca class="flex justify-between"><a href=/docs/observability/>Observability</a></label><ul><li><input type=checkbox id=section-7cc725eebd25c7e9d47ee7960b4ecfc1 class=toggle>
<label for=section-7cc725eebd25c7e9d47ee7960b4ecfc1 class="flex justify-between"><a href=/docs/observability/logs/>Logs</a></label><ul></ul></li><li><input type=checkbox id=section-e29f94eb5bd9d5aafdffbdb564e4bea2 class=toggle>
<label for=section-e29f94eb5bd9d5aafdffbdb564e4bea2 class="flex justify-between"><a href=/docs/observability/metrics/>Metrics</a></label><ul></ul></li><li><input type=checkbox id=section-8d1e9a9d4e5f691b5d7e5e80cf6ef1d7 class=toggle>
<label for=section-8d1e9a9d4e5f691b5d7e5e80cf6ef1d7 class="flex justify-between"><a href=/docs/observability/traces/>Traces</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-9105c59ef39a7595ef99c4bfb78bb81e class=toggle>
<label for=section-9105c59ef39a7595ef99c4bfb78bb81e class="flex justify-between"><a href=/docs/others/>Others</a></label><ul></ul></li><li><input type=checkbox id=section-6f49c67d25efc699d81e35c4fafa9a01 class=toggle>
<label for=section-6f49c67d25efc699d81e35c4fafa9a01 class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/>알고리즘</a></label><ul><li><input type=checkbox id=section-5b975705a333872de85a03a37b55295c class=toggle>
<label for=section-5b975705a333872de85a03a37b55295c class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/a-really-important/>a-really-important</a></label><ul></ul></li><li><input type=checkbox id=section-bc87be8373f3bf11211d5856ffcb8b9c class=toggle>
<label for=section-bc87be8373f3bf11211d5856ffcb8b9c class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/dp/>dp</a></label><ul></ul></li><li><input type=checkbox id=section-9722cc6c30ec4fb4be66597512cf805b class=toggle>
<label for=section-9722cc6c30ec4fb4be66597512cf805b class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/sorting/>sorting</a></label><ul></ul></li><li><input type=checkbox id=section-9b372b33221da2f276463adf685c1ac7 class=toggle>
<label for=section-9b372b33221da2f276463adf685c1ac7 class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/>완전탐색</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-5df15e14c1b4d2a21c95dbe819a034ac class=toggle checked>
<label for=section-5df15e14c1b4d2a21c95dbe819a034ac class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/>컴퓨터이론</a></label><ul><li><input type=checkbox id=section-a39ce00a2c75f70172122b9e0fb44a67 class=toggle>
<label for=section-a39ce00a2c75f70172122b9e0fb44a67 class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/>네트워크</a></label><ul></ul></li><li><input type=checkbox id=section-c3f58ce2e6e6f04354d15dc321113ad4 class=toggle>
<label for=section-c3f58ce2e6e6f04354d15dc321113ad4 class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/>데이터베이스</a></label><ul></ul></li><li><input type=checkbox id=section-a403b7d929a2700223698cf777076568 class=toggle>
<label for=section-a403b7d929a2700223698cf777076568 class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/>디자인패턴</a></label><ul></ul></li><li><input type=checkbox id=section-9c330bb0bf0f92f36cdb9d9a9d87c80a class=toggle checked>
<label for=section-9c330bb0bf0f92f36cdb9d9a9d87c80a class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/>운영체제</a></label><ul></ul></li><li><input type=checkbox id=section-d088173a2cae9127fdb45d64257adb52 class=toggle>
<label for=section-d088173a2cae9127fdb45d64257adb52 class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/>자료구조</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-a99d37744fc4a13077658ecab17cfde2 class=toggle>
<label for=section-a99d37744fc4a13077658ecab17cfde2 class="flex justify-between"><a href=/docs/%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85/>트러블슈팅</a></label><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>3. 프로세스 동기화(Process Synchronization)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-정의>1. 정의</a><ul><li><a href=#-임계-구역-critical-section>🔹 임계 구역 (Critical Section)</a></li><li><a href=#-동기화의-목적>🔹 동기화의 목적</a></li></ul></li><li><a href=#2-동기화의-3가지-요구-조건임계-구역-문제-해결-조건>2. 동기화의 3가지 요구 조건(임계 구역 문제 해결 조건)</a></li><li><a href=#3-동기화-주요-기법>3. 동기화 주요 기법</a></li><li><a href=#4-race-condition-예제와-해결-방법>4. Race COndition 예제와 해결 방법</a></li><li><a href=#5-실무-예시>5. 실무 예시</a></li><li><a href=#6-자주-묻는-면접-질문>6. 자주 묻는 면접 질문</a></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=1-정의>1. 정의
<a class=anchor href=#1-%ec%a0%95%ec%9d%98>#</a></h2><ul><li>프로세스 동기화란 둘 이상의 프로세스(또는 스레드)가 공유 자원에 접근할 때 충돌 없이 안전하게 작업할 수 있도록 보장하는 방법.</li><li>주로 임계 구역(Critical Section) 문제를 해결하기 위한 동기화 메커니즘을 의미.</li></ul><h3 id=-임계-구역-critical-section>🔹 임계 구역 (Critical Section)
<a class=anchor href=#-%ec%9e%84%ea%b3%84-%ea%b5%ac%ec%97%ad-critical-section>#</a></h3><ul><li>동시에 하나의 프로세스만 접근해야 하는 공유 자원 처리 구간.</li><li>예: 전역 변수, 공유된 파일, 네트워크 소켓 등</li></ul><h3 id=-동기화의-목적>🔹 동기화의 목적
<a class=anchor href=#-%eb%8f%99%ea%b8%b0%ed%99%94%ec%9d%98-%eb%aa%a9%ec%a0%81>#</a></h3><ul><li>Race Condition 방지: 둘 이상의 프로세스가 데이터를 동시에 읽고 쓰면 비정상적인 결과 발생</li><li>일관성 유지: 데이터 무결성 보장</li></ul><h2 id=2-동기화의-3가지-요구-조건임계-구역-문제-해결-조건>2. 동기화의 3가지 요구 조건(임계 구역 문제 해결 조건)
<a class=anchor href=#2-%eb%8f%99%ea%b8%b0%ed%99%94%ec%9d%98-3%ea%b0%80%ec%a7%80-%ec%9a%94%ea%b5%ac-%ec%a1%b0%ea%b1%b4%ec%9e%84%ea%b3%84-%ea%b5%ac%ec%97%ad-%eb%ac%b8%ec%a0%9c-%ed%95%b4%ea%b2%b0-%ec%a1%b0%ea%b1%b4>#</a></h2><ol><li>상호 배제 (Mutual Exclusion): 하나의 프로세스만 임계 구역 실행 가능</li><li>진행 (Progress): 임계 구역에 진입하지 않은 프로세스는 진입 여부 결정에 관여 X</li><li>한정 대기 (Bounded Waiting): 무한정 대기 없이 순차적으로 기회 부여</li></ol><h2 id=3-동기화-주요-기법>3. 동기화 주요 기법
<a class=anchor href=#3-%eb%8f%99%ea%b8%b0%ed%99%94-%ec%a3%bc%ec%9a%94-%ea%b8%b0%eb%b2%95>#</a></h2><ol><li>뮤텍스(Mutex, Mutual Exclusion Lock)</li></ol><ul><li>한 번에 하나의 스레드만 락을 획득 가능</li><li>획득한 스레드만 임계 구역 진입 → 완료 후 unlock</li><li>소유 개념 있음: 락을 걸고 해제할 수 있는 주체는 동일해야 함</li><li>사용 예시: pthread_mutex, Java synchronized, C++ std::mutex</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>pthread_mutex_t</span> lock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pthread_mutex_lock</span>(<span style=color:#f92672>&amp;</span>lock);
</span></span><span style=display:flex><span><span style=color:#75715e>// 임계 구역
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>pthread_mutex_unlock</span>(<span style=color:#f92672>&amp;</span>lock);
</span></span></code></pre></div><ol start=2><li>세마포어(Semaphore)</li></ol><ul><li>카운팅 가능한 동기화 도구</li><li>두 가지 연산:<ul><li>P() 또는 wait() → 자원 요청 (count–)</li><li>V() 또는 signal() → 자원 반납 (count++)</li></ul></li><li>음수가 되면 대기 큐에 블록됨</li><li>소유 개념 없음 → 다른 스레드가 해제 가능<table><thead><tr><th>종류</th><th>설명</th></tr></thead><tbody><tr><td>Binary Semaphore</td><td>0 or 1 (뮤텍스와 유사)</td></tr><tr><td>Counting Semaphore</td><td>특정 수 이상의 동시 접근 허용 가능</td></tr></tbody></table></li></ul><ol start=3><li>스핀락(Spinlock)</li></ol><ul><li>락을 획득할 때까지 CPU를 점유한 채 무한 루프(바쁜 대기).</li><li>컨텍스트 스위치가 비싼 커널 공간이나 짧은 락 소유 시 유리</li><li>주의: 멀티코어 환경에서만 유효하며, 싱글코어에서 사용하면 CPU 낭비</li></ul><ol start=4><li>모니터(Monitor)</li></ol><ul><li>언어 수준의 동기화 추상화</li><li>내부에 Lock + Condition Variable 포함</li><li>Java, C#, Go 등에서 사용 (synchronized, wait/notify, etc.)</li></ul><ol start=5><li>조건 변수 (Condition Variable)</li></ol><ul><li>어떤 조건이 만족될 때까지 기다리는 데 사용</li><li>주로 뮤텍스와 함께 사용</li><li>예시:<ul><li>pthread_cond_wait()</li><li>Java Object.wait() / Object.notify()</li></ul></li></ul><h2 id=4-race-condition-예제와-해결-방법>4. Race COndition 예제와 해결 방법
<a class=anchor href=#4-race-condition-%ec%98%88%ec%a0%9c%ec%99%80-%ed%95%b4%ea%b2%b0-%eb%b0%a9%eb%b2%95>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>increment</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> arg) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1000000</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        counter<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>위 코드에서 두 개의 스레드가 동시에 counter++를 수행하면 Race Condition 발생</li><li>해결책: mutex 사용</li></ul><h2 id=5-실무-예시>5. 실무 예시
<a class=anchor href=#5-%ec%8b%a4%eb%ac%b4-%ec%98%88%ec%8b%9c>#</a></h2><table><thead><tr><th>분야</th><th>동기화 방식</th></tr></thead><tbody><tr><td>다중 요청 처리 서버 (ex. Tomcat)</td><td>Thread Pool + 뮤텍스 / 세마포어</td></tr><tr><td>생산자-소비자 패턴</td><td>Circular Buffer + 조건 변수</td></tr><tr><td>DB connection pool</td><td>Counting Semaphore</td></tr><tr><td>커널 영역 (락 없는 프로그래밍 포함)</td><td>Spinlock, 원자 연산, CAS(Compare-And-Swap)</td></tr></tbody></table><h2 id=6-자주-묻는-면접-질문>6. 자주 묻는 면접 질문
<a class=anchor href=#6-%ec%9e%90%ec%a3%bc-%eb%ac%bb%eb%8a%94-%eb%a9%b4%ec%a0%91-%ec%a7%88%eb%ac%b8>#</a></h2><blockquote><p>Q1. 세마포어와 뮤텍스의 차이는?
A.</p></blockquote><ul><li>뮤텍스는 1개의 자원을 보호하며 소유 개념이 있다. 세마포어는 개수(count)를 가질 수 있고, 소유 개념이 없다. 또한 세마포어는 하나의 스레드가 wait, 다른 스레드가 signal 가능.</li></ul><blockquote><p>Q2. 스핀락은 언제 사용하나요?
A.</p></blockquote><ul><li>락 소유 시간이 매우 짧고, 컨텍스트 스위칭 비용이 큰 커널 공간 또는 멀티코어 환경에서 사용. 싱글코어에서는 오히려 성능 저하.</li></ul><blockquote><p>Q3. 뮤텍스를 사용하는데도 데드락이 발생하는 이유는?
A.</p></blockquote><ul><li>락의 획득 순서가 꼬이면 데드락 발생 가능. 다중 자원 요청 시 락 획득 순서 통일이 중요. 해결책: 타임아웃, 정렬된 순서로 요청, 락 순서 정책 등</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-정의>1. 정의</a><ul><li><a href=#-임계-구역-critical-section>🔹 임계 구역 (Critical Section)</a></li><li><a href=#-동기화의-목적>🔹 동기화의 목적</a></li></ul></li><li><a href=#2-동기화의-3가지-요구-조건임계-구역-문제-해결-조건>2. 동기화의 3가지 요구 조건(임계 구역 문제 해결 조건)</a></li><li><a href=#3-동기화-주요-기법>3. 동기화 주요 기법</a></li><li><a href=#4-race-condition-예제와-해결-방법>4. Race COndition 예제와 해결 방법</a></li><li><a href=#5-실무-예시>5. 실무 예시</a></li><li><a href=#6-자주-묻는-면접-질문>6. 자주 묻는 면접 질문</a></li></ul></nav></div></aside></main></body></html>