<!doctype html><html lang=ko dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  1. 정의
  #


CPU 스케줄링은 Ready Queue에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 정책.
멀티태스킹 OS에서 프로세스 간 CPU를 공유하기 위한 핵심 메커니즘.
OS의 핵심 기능 중 하나로, 스케줄러는 다양한 정책에 따라 프로세스를 선택함.


  주요 목적
  #


시스템 자원의 공정한 분배
CPU 사용률(Throughput) 극대화
대기 시간, 응답 시간 최소화
전반적인 시스템 반응성 향상


  2. 스케쥴링이 필요한 시점
  #


프로세스가 CPU burst를 마치고 I/O 요청 → CPU 반환
프로세스가 종료됨
선점형 스케줄러의 경우, 더 높은 우선순위의 프로세스가 도착
sleep(), wait() 호출 후 wake up될 때


  3. 주요 스케쥴링 기준
  #


  
      
          기준
          설명
      
  
  
      
          CPU burst time
          얼마나 짧게 CPU를 점유할지
      
      
          우선순위 (Priority)
          사용자/시스템 지정
      
      
          도착 시간 (Arrival Time)
          먼저 온 순서
      
      
          대기 시간 / 응답 시간
          유저가 체감하는 반응 속도
      
      
          Aging
          기아(Starvation) 방지 목적
      
  


  4. 스케쥴링 알고리즘
  #


FCFS (First-Come, First-Served)


먼저 온 순서대로 처리 (Queue 기반)
단순하지만 Convoy 현상 발생 가능 (긴 작업이 짧은 작업을 막음)


SJF (Shortest Job First)


CPU burst가 가장 짧은 작업 우선
이론상 가장 효율적 (대기시간 최소), 하지만 예측이 어렵다
비선점형(기본) 또는 **선점형(SRTF)**으로 구현 가능


Round Robin (RR)


각 프로세스에 Time Quantum 부여
시간 할당이 끝나면 선점 발생 → 공정성 ↑
응답성이 중요할 때 유용 (인터랙티브 시스템)


Priority Scheduling


우선순위 높은 작업부터 실행
Starvation 발생 가능 → Aging 기법으로 완화


Multi-Level Queue (MLQ)


프로세스를 성격에 따라 여러 큐로 분류 (ex. interactive, batch)
큐마다 별도 알고리즘 사용
큐 간 우선순위 존재 (low queue는 starvation 가능)


Multi-Level Feedback Queue (MLFQ)


MLQ 확장형, 프로세스가 다른 큐로 이동 가능
초기엔 높은 우선순위에서 시작, CPU 오래 쓰면 점점 낮은 우선순위로 이동
현대 OS가 채택하는 현실적인 정책


  5. 선점형 vs 비선점형
  #


  
      
          구분
          비선점형
          선점형
      
  
  
      
          설명
          CPU를 할당받으면 자발적으로 반환할 때까지 유지
          우선순위 등 조건에 따라 중간에 선점 가능
      
      
          예시 알고리즘
          FCFS, SJF
          RR, Priority(선점형), SRTF
      
      
          특징
          단순, context switch 적음
          응답성 우수, 복잡도 ↑
      
  


  6. 성능 지표
  #


  
      
          지표
          설명
      
  
  
      
          CPU 사용률
          CPU가 놀지 않고 일하는 비율
      
      
          Throughput
          단위 시간당 완료된 프로세스 수
      
      
          Turnaround Time
          프로세스 시작 ~ 종료까지 걸린 시간
      
      
          Waiting Time
          Ready Queue에서 기다린 시간
      
      
          Response Time
          요청 후 첫 반응까지 걸린 시간
      
  


  7. 실무 예시
  #


  
      
          OS
          스케줄러
      
  
  
      
          Linux (CFS)
          Completely Fair Scheduler – 시간 단위를 Weight로 변환해 공정하게 분배
      
      
          Windows
          Multilevel Feedback Queue 기반 선점형
      
      
          RTOS
          Priority-based preemptive scheduling (실시간성 강조)
      
  

=> 📌 Linux CFS는 가상 런타임(VRuntime) 기반으로, 각 태스크의 실행 시간을 추적하며 가장 “덜 사용한” 프로세스에게 CPU를 할당."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://stevearsenelee.iptime.org/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2-cpu-scheduling/"><meta property="og:site_name" content="LogLee's Training Ground"><meta property="og:title" content="2. CPU Scheduling"><meta property="og:description" content="1. 정의 # CPU 스케줄링은 Ready Queue에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 정책. 멀티태스킹 OS에서 프로세스 간 CPU를 공유하기 위한 핵심 메커니즘. OS의 핵심 기능 중 하나로, 스케줄러는 다양한 정책에 따라 프로세스를 선택함. 주요 목적 # 시스템 자원의 공정한 분배 CPU 사용률(Throughput) 극대화 대기 시간, 응답 시간 최소화 전반적인 시스템 반응성 향상 2. 스케쥴링이 필요한 시점 # 프로세스가 CPU burst를 마치고 I/O 요청 → CPU 반환 프로세스가 종료됨 선점형 스케줄러의 경우, 더 높은 우선순위의 프로세스가 도착 sleep(), wait() 호출 후 wake up될 때 3. 주요 스케쥴링 기준 # 기준 설명 CPU burst time 얼마나 짧게 CPU를 점유할지 우선순위 (Priority) 사용자/시스템 지정 도착 시간 (Arrival Time) 먼저 온 순서 대기 시간 / 응답 시간 유저가 체감하는 반응 속도 Aging 기아(Starvation) 방지 목적 4. 스케쥴링 알고리즘 # FCFS (First-Come, First-Served) 먼저 온 순서대로 처리 (Queue 기반) 단순하지만 Convoy 현상 발생 가능 (긴 작업이 짧은 작업을 막음) SJF (Shortest Job First) CPU burst가 가장 짧은 작업 우선 이론상 가장 효율적 (대기시간 최소), 하지만 예측이 어렵다 비선점형(기본) 또는 **선점형(SRTF)**으로 구현 가능 Round Robin (RR) 각 프로세스에 Time Quantum 부여 시간 할당이 끝나면 선점 발생 → 공정성 ↑ 응답성이 중요할 때 유용 (인터랙티브 시스템) Priority Scheduling 우선순위 높은 작업부터 실행 Starvation 발생 가능 → Aging 기법으로 완화 Multi-Level Queue (MLQ) 프로세스를 성격에 따라 여러 큐로 분류 (ex. interactive, batch) 큐마다 별도 알고리즘 사용 큐 간 우선순위 존재 (low queue는 starvation 가능) Multi-Level Feedback Queue (MLFQ) MLQ 확장형, 프로세스가 다른 큐로 이동 가능 초기엔 높은 우선순위에서 시작, CPU 오래 쓰면 점점 낮은 우선순위로 이동 현대 OS가 채택하는 현실적인 정책 5. 선점형 vs 비선점형 # 구분 비선점형 선점형 설명 CPU를 할당받으면 자발적으로 반환할 때까지 유지 우선순위 등 조건에 따라 중간에 선점 가능 예시 알고리즘 FCFS, SJF RR, Priority(선점형), SRTF 특징 단순, context switch 적음 응답성 우수, 복잡도 ↑ 6. 성능 지표 # 지표 설명 CPU 사용률 CPU가 놀지 않고 일하는 비율 Throughput 단위 시간당 완료된 프로세스 수 Turnaround Time 프로세스 시작 ~ 종료까지 걸린 시간 Waiting Time Ready Queue에서 기다린 시간 Response Time 요청 후 첫 반응까지 걸린 시간 7. 실무 예시 # OS 스케줄러 Linux (CFS) Completely Fair Scheduler – 시간 단위를 Weight로 변환해 공정하게 분배 Windows Multilevel Feedback Queue 기반 선점형 RTOS Priority-based preemptive scheduling (실시간성 강조) => 📌 Linux CFS는 가상 런타임(VRuntime) 기반으로, 각 태스크의 실행 시간을 추적하며 가장 “덜 사용한” 프로세스에게 CPU를 할당."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2. CPU Scheduling | LogLee's Training Ground</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://stevearsenelee.iptime.org/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2-cpu-scheduling/><link rel=stylesheet href=/book.min.e9f68c3fff3d8236a489d16a9caf6de5e4d1a29c20eb4b5524e42cd30be4d319.css integrity="sha256-6faMP/89gjakidFqnK9t5eTRopwg60tVJOQs0wvk0xk=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/kr.search.min.7519638bba906ebd7144ec6f10865974a0bf0a20eaf199bab28b9c08e4017da1.js integrity="sha256-dRlji7qQbr1xROxvEIZZdKC/CiDq8Zm6soucCOQBfaE=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>LogLee's Training Ground</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder aria-label maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-ca170abdbca9581a14670b9cae3bc610 class=toggle>
<label for=section-ca170abdbca9581a14670b9cae3bc610 class="flex justify-between"><a href=/docs/infra/>Infra</a></label><ul><li><input type=checkbox id=section-13e9d5199e5227e2fc9d2761cefce5e3 class=toggle>
<label for=section-13e9d5199e5227e2fc9d2761cefce5e3 class="flex justify-between"><a href=/docs/infra/kvm/>KVM</a></label><ul></ul></li><li><input type=checkbox id=section-f81e017d773579a54933834beb44e810 class=toggle>
<label for=section-f81e017d773579a54933834beb44e810 class="flex justify-between"><a href=/docs/infra/kubernetes/>Kubernetes</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-0a6b727fd0c16fe1cd97268a7c41867f class=toggle>
<label for=section-0a6b727fd0c16fe1cd97268a7c41867f class="flex justify-between"><a href=/docs/data-engineering/>Data Engineering</a></label><ul><li><input type=checkbox id=section-62b47f208465b78efb2357a9cd3b2079 class=toggle>
<label for=section-62b47f208465b78efb2357a9cd3b2079 class="flex justify-between"><a href=/docs/data-engineering/hadoop/>Hadoop</a></label><ul></ul></li><li><input type=checkbox id=section-78a946129d8f80712a11a39c8d6ebd9d class=toggle>
<label for=section-78a946129d8f80712a11a39c8d6ebd9d class="flex justify-between"><a href=/docs/data-engineering/modeling/>Modeling</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-f63bbdf8b75866dade3fafe4e1a0afff class=toggle>
<label for=section-f63bbdf8b75866dade3fafe4e1a0afff class="flex justify-between"><a href=/docs/data-integration/>Data Integration</a></label><ul><li><input type=checkbox id=section-79a0757d1ed364d3305442eeb8973397 class=toggle>
<label for=section-79a0757d1ed364d3305442eeb8973397 class="flex justify-between"><a href=/docs/data-integration/kafka/>Kafka</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-6112d994a830508704e67b42557ab468 class=toggle>
<label for=section-6112d994a830508704e67b42557ab468 class="flex justify-between"><a href=/docs/data-lake-platform/>Data Lake Platform</a></label><ul><li><input type=checkbox id=section-da639d08c72951def4c9aaca8e9ac1d2 class=toggle>
<label for=section-da639d08c72951def4c9aaca8e9ac1d2 class="flex justify-between"><a href=/docs/data-lake-platform/ceph/>Ceph</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-7943913a8058166e2057e211419337f8 class=toggle>
<label for=section-7943913a8058166e2057e211419337f8 class="flex justify-between"><a href=/docs/data-processing/>Data Processing</a></label><ul><li><input type=checkbox id=section-b4d28add6c8591349850bd55ed89041a class=toggle>
<label for=section-b4d28add6c8591349850bd55ed89041a class="flex justify-between"><a href=/docs/data-processing/flink/>Flink</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-780e6985e21edbc7ed69c6dc3b8333e0 class=toggle>
<label for=section-780e6985e21edbc7ed69c6dc3b8333e0 class="flex justify-between"><a href=/docs/language/>Language</a></label><ul></ul></li><li><input type=checkbox id=section-fff819996f2500b94ce5cef541863bca class=toggle>
<label for=section-fff819996f2500b94ce5cef541863bca class="flex justify-between"><a href=/docs/observability/>Observability</a></label><ul><li><input type=checkbox id=section-7cc725eebd25c7e9d47ee7960b4ecfc1 class=toggle>
<label for=section-7cc725eebd25c7e9d47ee7960b4ecfc1 class="flex justify-between"><a href=/docs/observability/logs/>Logs</a></label><ul></ul></li><li><input type=checkbox id=section-e29f94eb5bd9d5aafdffbdb564e4bea2 class=toggle>
<label for=section-e29f94eb5bd9d5aafdffbdb564e4bea2 class="flex justify-between"><a href=/docs/observability/metrics/>Metrics</a></label><ul></ul></li><li><input type=checkbox id=section-8d1e9a9d4e5f691b5d7e5e80cf6ef1d7 class=toggle>
<label for=section-8d1e9a9d4e5f691b5d7e5e80cf6ef1d7 class="flex justify-between"><a href=/docs/observability/traces/>Traces</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-9105c59ef39a7595ef99c4bfb78bb81e class=toggle>
<label for=section-9105c59ef39a7595ef99c4bfb78bb81e class="flex justify-between"><a href=/docs/others/>Others</a></label><ul></ul></li><li><input type=checkbox id=section-6f49c67d25efc699d81e35c4fafa9a01 class=toggle>
<label for=section-6f49c67d25efc699d81e35c4fafa9a01 class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/>알고리즘</a></label><ul><li><input type=checkbox id=section-5b975705a333872de85a03a37b55295c class=toggle>
<label for=section-5b975705a333872de85a03a37b55295c class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/a-really-important/>a-really-important</a></label><ul></ul></li><li><input type=checkbox id=section-bc87be8373f3bf11211d5856ffcb8b9c class=toggle>
<label for=section-bc87be8373f3bf11211d5856ffcb8b9c class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/dp/>dp</a></label><ul></ul></li><li><input type=checkbox id=section-9722cc6c30ec4fb4be66597512cf805b class=toggle>
<label for=section-9722cc6c30ec4fb4be66597512cf805b class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/sorting/>sorting</a></label><ul></ul></li><li><input type=checkbox id=section-9b372b33221da2f276463adf685c1ac7 class=toggle>
<label for=section-9b372b33221da2f276463adf685c1ac7 class="flex justify-between"><a href=/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/>완전탐색</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-5df15e14c1b4d2a21c95dbe819a034ac class=toggle checked>
<label for=section-5df15e14c1b4d2a21c95dbe819a034ac class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/>컴퓨터이론</a></label><ul><li><input type=checkbox id=section-a39ce00a2c75f70172122b9e0fb44a67 class=toggle>
<label for=section-a39ce00a2c75f70172122b9e0fb44a67 class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/>네트워크</a></label><ul></ul></li><li><input type=checkbox id=section-c3f58ce2e6e6f04354d15dc321113ad4 class=toggle>
<label for=section-c3f58ce2e6e6f04354d15dc321113ad4 class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/>데이터베이스</a></label><ul></ul></li><li><input type=checkbox id=section-a403b7d929a2700223698cf777076568 class=toggle>
<label for=section-a403b7d929a2700223698cf777076568 class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/>디자인패턴</a></label><ul></ul></li><li><input type=checkbox id=section-9c330bb0bf0f92f36cdb9d9a9d87c80a class=toggle checked>
<label for=section-9c330bb0bf0f92f36cdb9d9a9d87c80a class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/>운영체제</a></label><ul></ul></li><li><input type=checkbox id=section-d088173a2cae9127fdb45d64257adb52 class=toggle>
<label for=section-d088173a2cae9127fdb45d64257adb52 class="flex justify-between"><a href=/docs/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%B4%EB%A1%A0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/>자료구조</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-a99d37744fc4a13077658ecab17cfde2 class=toggle>
<label for=section-a99d37744fc4a13077658ecab17cfde2 class="flex justify-between"><a href=/docs/%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85/>트러블슈팅</a></label><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2. CPU Scheduling</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-정의>1. 정의</a><ul><li><a href=#주요-목적>주요 목적</a></li></ul></li><li><a href=#2-스케쥴링이-필요한-시점>2. 스케쥴링이 필요한 시점</a></li><li><a href=#3-주요-스케쥴링-기준>3. 주요 스케쥴링 기준</a></li><li><a href=#4-스케쥴링-알고리즘>4. 스케쥴링 알고리즘</a></li><li><a href=#5-선점형-vs-비선점형>5. 선점형 vs 비선점형</a></li><li><a href=#6-성능-지표>6. 성능 지표</a></li><li><a href=#7-실무-예시>7. 실무 예시</a></li><li><a href=#8-자주-묻는-면접-질문>8. 자주 묻는 면접 질문</a></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=1-정의>1. 정의
<a class=anchor href=#1-%ec%a0%95%ec%9d%98>#</a></h2><ul><li>CPU 스케줄링은 Ready Queue에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 정책.</li><li>멀티태스킹 OS에서 프로세스 간 CPU를 공유하기 위한 핵심 메커니즘.</li><li>OS의 핵심 기능 중 하나로, 스케줄러는 다양한 정책에 따라 프로세스를 선택함.</li></ul><h3 id=주요-목적>주요 목적
<a class=anchor href=#%ec%a3%bc%ec%9a%94-%eb%aa%a9%ec%a0%81>#</a></h3><ul><li>시스템 자원의 공정한 분배</li><li>CPU 사용률(Throughput) 극대화</li><li>대기 시간, 응답 시간 최소화</li><li>전반적인 시스템 반응성 향상</li></ul><h2 id=2-스케쥴링이-필요한-시점>2. 스케쥴링이 필요한 시점
<a class=anchor href=#2-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81%ec%9d%b4-%ed%95%84%ec%9a%94%ed%95%9c-%ec%8b%9c%ec%a0%90>#</a></h2><ul><li>프로세스가 CPU burst를 마치고 I/O 요청 → CPU 반환</li><li>프로세스가 종료됨</li><li>선점형 스케줄러의 경우, 더 높은 우선순위의 프로세스가 도착</li><li>sleep(), wait() 호출 후 wake up될 때</li></ul><h2 id=3-주요-스케쥴링-기준>3. 주요 스케쥴링 기준
<a class=anchor href=#3-%ec%a3%bc%ec%9a%94-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81-%ea%b8%b0%ec%a4%80>#</a></h2><table><thead><tr><th>기준</th><th>설명</th></tr></thead><tbody><tr><td>CPU burst time</td><td>얼마나 짧게 CPU를 점유할지</td></tr><tr><td>우선순위 (Priority)</td><td>사용자/시스템 지정</td></tr><tr><td>도착 시간 (Arrival Time)</td><td>먼저 온 순서</td></tr><tr><td>대기 시간 / 응답 시간</td><td>유저가 체감하는 반응 속도</td></tr><tr><td>Aging</td><td>기아(Starvation) 방지 목적</td></tr></tbody></table><h2 id=4-스케쥴링-알고리즘>4. 스케쥴링 알고리즘
<a class=anchor href=#4-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98>#</a></h2><ol><li>FCFS (First-Come, First-Served)</li></ol><ul><li>먼저 온 순서대로 처리 (Queue 기반)</li><li>단순하지만 Convoy 현상 발생 가능 (긴 작업이 짧은 작업을 막음)</li></ul><ol start=2><li>SJF (Shortest Job First)</li></ol><ul><li>CPU burst가 가장 짧은 작업 우선</li><li>이론상 가장 효율적 (대기시간 최소), 하지만 예측이 어렵다</li><li>비선점형(기본) 또는 **선점형(SRTF)**으로 구현 가능</li></ul><ol start=3><li>Round Robin (RR)</li></ol><ul><li>각 프로세스에 Time Quantum 부여</li><li>시간 할당이 끝나면 선점 발생 → 공정성 ↑</li><li>응답성이 중요할 때 유용 (인터랙티브 시스템)</li></ul><ol start=4><li>Priority Scheduling</li></ol><ul><li>우선순위 높은 작업부터 실행</li><li>Starvation 발생 가능 → Aging 기법으로 완화</li></ul><ol start=5><li>Multi-Level Queue (MLQ)</li></ol><ul><li>프로세스를 성격에 따라 여러 큐로 분류 (ex. interactive, batch)</li><li>큐마다 별도 알고리즘 사용</li><li>큐 간 우선순위 존재 (low queue는 starvation 가능)</li></ul><ol start=6><li>Multi-Level Feedback Queue (MLFQ)</li></ol><ul><li>MLQ 확장형, 프로세스가 다른 큐로 이동 가능</li><li>초기엔 높은 우선순위에서 시작, CPU 오래 쓰면 점점 낮은 우선순위로 이동</li><li>현대 OS가 채택하는 현실적인 정책</li></ul><h2 id=5-선점형-vs-비선점형>5. 선점형 vs 비선점형
<a class=anchor href=#5-%ec%84%a0%ec%a0%90%ed%98%95-vs-%eb%b9%84%ec%84%a0%ec%a0%90%ed%98%95>#</a></h2><table><thead><tr><th>구분</th><th>비선점형</th><th>선점형</th></tr></thead><tbody><tr><td>설명</td><td>CPU를 할당받으면 자발적으로 반환할 때까지 유지</td><td>우선순위 등 조건에 따라 중간에 선점 가능</td></tr><tr><td>예시 알고리즘</td><td>FCFS, SJF</td><td>RR, Priority(선점형), SRTF</td></tr><tr><td>특징</td><td>단순, context switch 적음</td><td>응답성 우수, 복잡도 ↑</td></tr></tbody></table><h2 id=6-성능-지표>6. 성능 지표
<a class=anchor href=#6-%ec%84%b1%eb%8a%a5-%ec%a7%80%ed%91%9c>#</a></h2><table><thead><tr><th>지표</th><th>설명</th></tr></thead><tbody><tr><td>CPU 사용률</td><td>CPU가 놀지 않고 일하는 비율</td></tr><tr><td>Throughput</td><td>단위 시간당 완료된 프로세스 수</td></tr><tr><td>Turnaround Time</td><td>프로세스 시작 ~ 종료까지 걸린 시간</td></tr><tr><td>Waiting Time</td><td>Ready Queue에서 기다린 시간</td></tr><tr><td>Response Time</td><td>요청 후 첫 반응까지 걸린 시간</td></tr></tbody></table><h2 id=7-실무-예시>7. 실무 예시
<a class=anchor href=#7-%ec%8b%a4%eb%ac%b4-%ec%98%88%ec%8b%9c>#</a></h2><table><thead><tr><th>OS</th><th>스케줄러</th></tr></thead><tbody><tr><td>Linux (CFS)</td><td>Completely Fair Scheduler – 시간 단위를 Weight로 변환해 공정하게 분배</td></tr><tr><td>Windows</td><td>Multilevel Feedback Queue 기반 선점형</td></tr><tr><td>RTOS</td><td>Priority-based preemptive scheduling (실시간성 강조)</td></tr></tbody></table><p>=> 📌 Linux CFS는 가상 런타임(VRuntime) 기반으로, 각 태스크의 실행 시간을 추적하며 가장 “덜 사용한” 프로세스에게 CPU를 할당.</p><h2 id=8-자주-묻는-면접-질문>8. 자주 묻는 면접 질문
<a class=anchor href=#8-%ec%9e%90%ec%a3%bc-%eb%ac%bb%eb%8a%94-%eb%a9%b4%ec%a0%91-%ec%a7%88%eb%ac%b8>#</a></h2><blockquote><p>Q1. SJF가 이상적으로 효율적인 이유는?</p></blockquote><p>A.</p><ul><li>SJF는 평균 대기 시간을 수학적으로 최소화하는 최적 알고리즘.</li><li>하지만 실제 CPU burst time을 정확히 예측하는 건 어렵기 때문에 실무 적용이 제한적.</li></ul><blockquote><p>Q2. Round Robin의 타임퀀텀 크기는 어떻게 결정해야 하나요?</p></blockquote><p>A.</p><ul><li>너무 작으면 context switching 오버헤드 증가</li><li>너무 크면 FCFS처럼 변함</li><li>일반적으로 10~100ms 수준</li></ul><blockquote><p>Q3. 선점형 스케줄링이 필요한 이유는?</p></blockquote><p>A.</p><ul><li>실시간 반응이 필요한 환경 (GUI, 인터랙티브 shell 등)</li><li>짧은 작업이 긴 작업에 의해 밀리는 것을 방지</li></ul><blockquote><p>Q4. 멀티코어 환경에서 스케줄링은 어떻게 동작하나요?</p></blockquote><ul><li>각 CPU에 Run Queue를 두는 per-CPU 모델 사용</li><li>부하 분산을 위한 load balancing 또는 task migration 전략 필요</li><li>Linux는 SMP(Symmetric Multi Processing) 스케줄러로 처리</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-정의>1. 정의</a><ul><li><a href=#주요-목적>주요 목적</a></li></ul></li><li><a href=#2-스케쥴링이-필요한-시점>2. 스케쥴링이 필요한 시점</a></li><li><a href=#3-주요-스케쥴링-기준>3. 주요 스케쥴링 기준</a></li><li><a href=#4-스케쥴링-알고리즘>4. 스케쥴링 알고리즘</a></li><li><a href=#5-선점형-vs-비선점형>5. 선점형 vs 비선점형</a></li><li><a href=#6-성능-지표>6. 성능 지표</a></li><li><a href=#7-실무-예시>7. 실무 예시</a></li><li><a href=#8-자주-묻는-면접-질문>8. 자주 묻는 면접 질문</a></li></ul></nav></div></aside></main></body></html>