---
title:  "[Docker&Kubernetes] Container Infra Environment"
excerpt: "Kubernetes Introduction"

categories:
  - Docker&Kubernetes
tags:
  - [Docker&Kubernetes]

toc: true
toc_sticky: true
 
date: 2021-07-07
last_modified_at: 2021-07-07
---
### 컨테이너 인프라 환경
리눅스 운영체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경
- 컨테이너 : 하나 이상의 목적을 위해 독립적으로 작동하는 프로세스

> 쿠버네티스는 컨테이너 오케스트레이션을 위한 솔루션
- 오케스트레이션 : 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것
<br>
### 컨테이너 오케스트레이션을 제공하는 솔루션
- Docker Swarm : 간단하게 설치할 수 있고 사용하기도 용이하지만 기능이 다양하지 않아 대규모 환경에 적용시 사용자 환경을 변경. => 소규모에 유용
- Mesos : Apache의 오픈 소스 프로젝트. 기능을 충분히 활용하려면 분산 관리 시스템과 연동
- Nomad : 베이그런트를 만든 HashiCorp사의 제품. 베이그런트처럼 간단한 구성으로 컨테이너 오케스트레이션 환경 제공.

## 쿠버네티스 구성 방법
1. 퍼블릭 클라우드 업체에서 제공하는 관리형 쿠버네티스인 EKS(Amazon Elastic Kubernetes Service), AKS(Azure Kubernetes Services), GKE(Google Kubernetes Engine)등을 사용. 구성이 이미 다 갖춰져 있고 마스터 노드를 클라우드 업체에서 관리하기 때문에 학습용으로는 적합하지 않음
2. 수세의 Rancher, 레드햇의 OpenShift와 같은 플랫폼에서 제공하는 설치형 쿠버네티스를 사용. 유료라 쉽게 접근하기 힘듬
3. 사용하는 시스템에 쿠버네티스 클러스터를 자동으로 구성해주는 솔루션 사용. 주요 솔루션으로는 kubeadm, kops(Kubernetes Operations), KRIB(Kubernetes Rebar Integrated Bootstrap), kubespray가 있음. 4가지 주요 솔루션 중에 kubeadm이 가장 널리 알려져 있고 사용자가 변경하기도 수월하고, on-premises와 클라우드를 모두 지원하며, 배우기도 쉬움. 이러한 솔루션들을 구성형 쿠버네티스라고 함.

## 마스터 노드

- kubectl : 쿠버네티스 클러스터에 명령을 내리는 역할. 다른 구성 요소들과 다르게 바로 실행되는 명령 형태인 binary로 배포되기 때문에 마스터 노드에 있을 필요는 없음.
- API 서버 : 쿠버네티스 클러스터의 중심 역할을 하는 통로. 주로 상태 값을 저장하는 etcd와 통신하지만, 그 밖의 요소들 또한 API 서버를 중심에 두고 통신하므로 API 서버의 역할이 매우 중요. 회사에 비유하면 모든 직원과 상황을 관리하고 목표를 설정하는 관리자에 해당.
- etcd : 구성 요소들의 상태 값이 모두 저장된 곳. etcd의 정보만 백업돼 있다면 긴급한 장애 상황에서도 쿠버네티스 클러스터는 복구 가능. 또한 etcd는 분산 저장이 가능한 key-value 저장소이므로, 복제해 여러 곳에 저장해 두면 하나의 etcd에서 장애가 나더라도 시스템의 가용성을 확보할 수 있음.
- 컨트롤러 매니저 : 컨트롤러 매니저는 쿠버네티스 클러스터의 오브젝트 상태를 관리. 예를 들어 워커 노드에서 통신이 되지 않는 경우, 상태 체크와 복구는 컨트롤러 매니저에 속한 노드 컨트롤러에서 이루어짐. 다른 예로 레플리카셋 컨트롤러는 레플리카셋에 요청답은 파드 개수대로 파드 생성.
- 스케쥴러 : 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당. 스케쥴러라는 이름에 걸맞게 파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리하는 역할을 담당.

## 워커 노드

- kubelet : 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링함.
- 컨테이너 런타임(CRI, Container Tuntime Interface) : 파드를 이루는 컨테이너의 실행을 담당. 파드 안에서 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스
- 파드 : 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위. 즉, 웹 서버 역할을 할 수도 있고 로그나 데이터를 분석할 수 도 있음. 여기서 중요한 것은 파드는 언제라도 죽을 수 있는 존재.

### 부가 요소

- 네트워크 플러그인 : 쿠버네티스 클러스터의 통신을 위해서 네트워크 플러그인을 선택하고 구성. 네트워크 플러그인은 일반적으로 CNI로 구성하는데, 주로 사용하는 CNI에는 Calico, Flannel, Cilium, Kube-router, Romana, WeaveNet, Canal이 있음.
- CoreDNS : 클라우드 네이티브 컴퓨팅 재단에서 보증하는 프로젝트로, 빠르고 유연한 DNS 서버.

### 사용자가 배포된 파드에 접속하는 과정

1. kube-proxy : 쿠버네티스 클러스터는 파드가 위치한 노드에 kube-proxy를 통해 파드가 통신할 수 있는 네트워크를 설정. 이때 실제 통신은 br_netfilter와 iptables로 관리.
2. 파드 : 이미 배포된 파드에 접속하고 필요한 내용을 전달받음. 이때 대부분 사용자는 파드가 어느 워커 노드에 위치하는지 신경 쓰지 않아도 됨.

### 파드의 생명주기(life cycle)

1. kubectl을 통해 API 서버에 파드 생성 요청
2. (업데이트가 있을 때마다 매번) API 서버에 전달된 내용이 있으면 API 서버는 etcd에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지. 따라서 각 요소가 상태를 업데이트할 때마다 모두 API서버를 통해 etcd에 기록됨.
3. API 서버에 파드 생성이 요청된 것을 컨트롤러 매니저가 인지하면 컨트롤러 매니저는 파드를 생성하고, 이 상태를 API 서버에 전달. 이때 어떤 워커 노드에 파드를 적용할지는 결정되지 않은 상태로 파드만 생성
4. API 서버에 파드가 생성됐다는 정보를 스케쥴러가 인지. 스케쥴러는 생성된 파드를 어떤 워커 노드에 적용할지 조건을 고려해 결정하고 해당 워커 노드에 파드를 띄우도록 요청
5. API 서버에 전달된 정보대로 지정한 워커 노드에 파드가 속해 있는지 스케쥴러가 kubelet으로 확인
6. kubelet에서 컨테이너 런타임으로 파드 생성 요청
7. 파드 생성
8. 파드가 사용 가능한 상태가 됨

> 쿠버네티스는 작업을 순서대로 진행하는 workflow구조가 아니라 declarative시스템 구조를 가지고 있음. 즉, 각 요소가 desired status를 선언하면 current status와 맞는지 점검하고 그것에 맞추려고 노력하는 구조로 돼있음.

따라서 추가하는 상태를 API 서버에 선언하면 다른 요소들이 API 서버에 와서 현재 상태와 비교하고 그에 맞게 상태를 변경. API 서버와 etcd는 거의 한몸처럼 움직이도록 설계됨.

### kubelet

kubelet은 쿠버네티스에서 파드의 생성과 상태 관리 및 복구 등을 담당하는 매우 중요한 구성 요소. 따라서 kubelet에 문제가 생기면 파드가 정상적으로 관리되지 않음.

### kube-proxy

kubelet이 파드의 상태를 관리한다면 kube-proxy는 파드의 통신을 담당