---
title:  "[Docker&Kubernetes] Docker"
excerpt: "Docker"

categories:
  - Docker&Kubernetes
tags:
  - [Docker&Kubernetes]

toc: true
toc_sticky: true
 
date: 2021-07-27
last_modified_at: 2021-07-27
---
> 기존에 알아야되는 내용들
    - 쿠버네티스는 컨테이너를 오케스트레이션하며, 오케스트레이션하는 기본 단위는 파드
    - 파드는 컨테이너로 이루어져있음

## 파드, 컨테이너, 도커, 쿠버네티스의 관계
파드들은 워커 노드라는 노드 단위로 관리하며, 워커 노드와 마스터 노드가 모여 쿠버네티스 클러스터가 됨. 그리고 파드는 1개 이상의 컨테이너로 이루어져 있음.
파드는 쿠버네티스로부터 IP를 받아 컨테이너가 외부와 통신할 수 있는 경로를 제공. 그리고 컨테이너들이 정상적으로 작동하는지 확인하고 네트워크나 저장 공간을 서로 공유하게 함.
컨테이너를 돌보는 것이 파드고, 파드를 돌보는 것이 쿠버네티스 워커 노드이며, 워커 노드를 돌보는 것이 쿠버네티스 마스터.

가장 기본인 컨테이너는 하나의 운영 체제 안에서 커널을 공유하며 개별적인 실행 환경을 제공하는 격리된 공간. 개별적인 실행 환경이란 CPU, 네트워크, 메모리와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환경. 개별적인 실행 환경에선 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리돼 관리. 따라서 각 컨테이너 내부에서 실행되는 앱들은 서로 영향을 미치지않고 독립적으로 작동.

- 도커 : 컨테이너를 사용하는 방법을 명령어로 정리한 것

도커를 사용하면 사용자가 서로 신경쓰지 않아도 컨테이너를 생성할 때 개별적인 실행 환경을 분리하고 자원을 할당

### Different kinds of Container controller
- Containerd
- CRI-O
- Kata Containers
- Docker

## Docker
도커의 학습 과정
이미지 찾기 -> 실행 -> 디렉터리와 연결 -> 삭제

컨테이너 이미지는 그대로 사용할수 없고 도커와 같은 CRI로 불러들여야 컨테이너가 실제로 작동. 이는 실행 파일과 실행된 파일 관계로 볼 수 있음. 따라서 컨테이너를 삭제할 때는 내려받은 이미지와 이미 실행된 컨테이너를 모두 삭제해야만 디스크의 용량을 온전히 확보할 수 있음.

### Container Image
이미지는 registry라는 저장소에 모여 있음. registry는 docker hub같이 유명한 registry일 수도 있고, 내부에 구축한 registry일 수도 있음.
```powershell
docker search <검색어>
```
로 특정한 이름을 포함하는 이미지를 찾음.
- INDEX : 이미지가 저장된 레지스트리의 이름
- NAME : 검색된 이미지 이름. 공식 이미지를 제외한 니머지는 '레지스트리 주소/저장소 소유자/이미지 이름' 형태
- DESCRIPTION : 이미지에 대한 설명
- STARS : 해당 이미지를 내려받은 사용자에게 받은 평가 횟수. 숫자가 클수록 신뢰성 높은 이미지
- OFFICIAL : [OK]표시는 해당 이미지에 포함된 앱, 미들웨어 등을 개발한 업체에서 공식적으로 제공한 이미지
- AUTOMATED : [OK]표시는 도커 허브에서 자체적으로 제공하는 이미지 빌드 자동화 기능을 활용해 생성한 이미지를 의미

```powershell
docker pull nginx
```
이미지를 내려받을 때 사용하는 태그, 레이어, 이미지의 고유 식별 값 등을 볼 수 있음.
- tag : Using default tag와 함께 뒤에 따라오는 태그 이름을 통해 이미지를 내려받을 때 사용한 태그를 알 수 있음.
- layer : pull을 수행해 내려받은 레이어. 하나의 이미지는 여러 개의 레이어로 이루어져 있어서 레이어마다 Pull complete 메시지가 발생.
- digest : 이미지의 고유 식별자로, 이미지에 포함된 내용과 이미지의 생성 환경을 식별할 수 있음. 식별자는 hash함수로 생성되며 이미지가 동일한지 검증하는데 사용.
- status : 이미지를 내려받은 레지스트리, 이미지, 태그 등의 상태 정보를 확인할 수 있음. 형식은 '레지스트리 이름/이미지 이름:태그'

### Image Tag
태그는 이름이 동일한 이미지에 추가하는 식별자. 이미지를 내려받거나 이미지를 기반으로 컨테이너를 구동할 때는 이미지 이름만 사용하고 태그를 명시하지 않으면 latest 태그를 기본으로 사용. 안정화 버전은 stable로 실행.

### 이미지의 레이어 구조
```powershell
docker pull nginx:stable
docker images nginx
docker history nginx:stable
docker history nginx:latest
```

## 컨테이너 실행
새로운 컨테이너 실행
```powershell
docker run -d --restart always nginx
```
> docker run [옵션] <사용할 이미지 이름>[:태그 | @다이제스트]
- 태그와 다이제스트는 생략 가능
- -d(--detach) : 컨테이너를 백그라운드에서 구동한다는 의미. 옵션을 생략하면 컨테이너 내부에서 실행되는 애플리케이션의 상태가 화면에 계속 표시됨.
- --restart always : 컨테이너의 재시작과 관련된 정책을 의미하는 옵션. 프로그램에 예상하지 못한 오류가 발생하거나 리눅스 시스템에서 도커 서비스가 중지되는 경우에 컨테이너도 작동이 중지됨.

컨테이너 상태를 확인
```powershell
docker ps
```
- CONTAINER ID : 컨테이너를 식별하기 위한 고유 ID. ID에는 docker run를 실행한 결과가 일부 표시되는데 이를 통해 이미지나 컨테이너를 식별할 수 있음.
- IMAGE : 컨테이너를 만드는 데 사용한 이미지
- COMMAND : 컨테이너가 생성될 때 내부에서 작동할 프로그램을 실행할 명령어.
- CREATED : 컨테이너가 생성된 시각 표시
- STATUS : 컨테이너가 작동을 시작한 시각을 표시. CREATED와 달리 컨테이너를 중지했다가 다시 시작할 경우 초기화됨
- PORTS : 컨테이너가 사용하는 포트와 프로토콜 표시.
- NAMES : 컨테이너 이름을 표시.

컨테이너를 지정해 검색
```powershell
docker ps -f id=cec7
```
id=cec7이라는 필터링 대상을 지정해 CONTAINER ID에 cec7이라는 문자열이 포함된 컨테이너만 출력
> docker ps에 -f(--filter) <필터링 대상> 옵션을 주면 검색 결과를 필터링할 수 있음.
- 필터링 대상을 지정할 때는 key(대상)=value(값) 형식으로 입력


##### 추가로 경로를 설정해 정상적으로 컨테이너 실행하기
1. 새로운 컨테이너 실행
    ```powershell
    docker run -d -p 8080:80 --name nginx-exposed --restart always nginx
    ```
    여기서 -p(--publish)는 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션으로, -p <요청받을 호스트 포트>:<연결할 컨테이너 포트> 형식으로 사용
2. 컨테이너가 제대로 작동하는지 docker ps로 확인. -f name=nginx-exposed옵션으로 필터링
    ```powershell
    docker ps -f name=nginx-exposed
    ```

### 컨테이너 내부 파일 변경
도커는 컨테이너 내부에서 컨테이너 외부의 파일을 사용할 수 있는 방법으로 크게 4가지를 제공
- docker cp
    > docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로>
    
    형식으로 호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사.
    따라서 컨테이너에 임시로 펼요한 파일이 있는 경우 단편적으로 전송하기 위해 사용. 또는 컨테이너에 저장되있는 설정 및 로그를 추출해 확인하는 목적으로도 사용
- Dockerfile ADD
    - Dockerfile에 ADD라는 구문으로 컨테이너 내부로 복사할 파일을 지정하면 이미지를 빌드할 때 지정한 파일이 이미지 내부로 복사됨. 이후 해당 이미지를 기반으로 구동한 컨테이너에서는 복사한 파일을 사용할 수 있음. 그러나 사용자가 원하는 파일을 선택해 사용할 수 없다는 약점 존재
- 바인드 마운트
    - 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법. 새로운 컨테이너를 구동할 때도 호스트와 연결할 파일이나 디렉터리의 경로만 지정하면 다른 컨테이너에 있는 파일을 새로 생성한 컨테이너와 연결할 수 있음.
- 볼륨
    - 호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일하지만, 호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결.

##### 바인드 마운트로 호스트와 컨테이너 연결
1. 컨테이너 내부에 연결할 /root/html/ 디렉터리를 호스트에 생성
    ```powershell
    mkdir -p /root/html
    ```
2. docker run으로 컨테이너를 구동하고, 컨테이너의 디렉터리와 호스트의 디렉터리를 연결. -v(--volume)는 호스트 디렉터리와 컨테이너 디렉터리를 연결하는 옵션으로, -v <호스트 디렉터리 경로>:[컨테이너 디렉터리 경로] 형식으로 사용
    ```powershell
    docker run -d -p 8081:80 \
    -v /root/html:/usr/share/nginx/html --restart always --name nginx-bind-mounts nginx
    ```
3. 컨테이너를 조회해 STATUS가 정상(Up n minutes)인지 확인
    ```powershell
    docker ps -f name=nginx-bind-mounts
    ```
4. 컨테이너가 정상적으로 구동했음을 확인하면 컨테이너 내부와 연결된 디렉터리를 확인.
    ```powershell
    ls /root/html
    ```
